from _typeshed import Incomplete

__all__ = ['lti', 'dlti', 'TransferFunction', 'ZerosPolesGain', 'StateSpace', 'lsim', 'impulse', 'step', 'bode', 'freqresp', 'place_poles', 'dlsim', 'dstep', 'dimpulse', 'dfreqresp', 'dbode']

class LinearTimeInvariant:
    def __new__(cls, *system, **kwargs): ...
    inputs: Incomplete
    outputs: Incomplete
    def __init__(self) -> None: ...
    @property
    def dt(self): ...
    @property
    def zeros(self): ...
    @property
    def poles(self): ...

class lti(LinearTimeInvariant):
    def __new__(cls, *system): ...
    def __init__(self, *system) -> None: ...
    def impulse(self, X0: Incomplete | None = None, T: Incomplete | None = None, N: Incomplete | None = None): ...
    def step(self, X0: Incomplete | None = None, T: Incomplete | None = None, N: Incomplete | None = None): ...
    def output(self, U, T, X0: Incomplete | None = None): ...
    def bode(self, w: Incomplete | None = None, n: int = 100): ...
    def freqresp(self, w: Incomplete | None = None, n: int = 10000): ...
    def to_discrete(self, dt, method: str = 'zoh', alpha: Incomplete | None = None) -> None: ...

class dlti(LinearTimeInvariant):
    def __new__(cls, *system, **kwargs): ...
    def __init__(self, *system, **kwargs) -> None: ...
    @property
    def dt(self): ...
    @dt.setter
    def dt(self, dt) -> None: ...
    def impulse(self, x0: Incomplete | None = None, t: Incomplete | None = None, n: Incomplete | None = None): ...
    def step(self, x0: Incomplete | None = None, t: Incomplete | None = None, n: Incomplete | None = None): ...
    def output(self, u, t, x0: Incomplete | None = None): ...
    def bode(self, w: Incomplete | None = None, n: int = 100): ...
    def freqresp(self, w: Incomplete | None = None, n: int = 10000, whole: bool = False): ...

class TransferFunction(LinearTimeInvariant):
    def __new__(cls, *system, **kwargs): ...
    def __init__(self, *system, **kwargs) -> None: ...
    @property
    def num(self): ...
    outputs: int
    inputs: int
    @num.setter
    def num(self, num) -> None: ...
    @property
    def den(self): ...
    @den.setter
    def den(self, den) -> None: ...
    def to_tf(self): ...
    def to_zpk(self): ...
    def to_ss(self): ...

class TransferFunctionContinuous(TransferFunction, lti):
    def to_discrete(self, dt, method: str = 'zoh', alpha: Incomplete | None = None): ...

class TransferFunctionDiscrete(TransferFunction, dlti): ...

class ZerosPolesGain(LinearTimeInvariant):
    def __new__(cls, *system, **kwargs): ...
    def __init__(self, *system, **kwargs) -> None: ...
    @property
    def zeros(self): ...
    outputs: int
    inputs: int
    @zeros.setter
    def zeros(self, zeros) -> None: ...
    @property
    def poles(self): ...
    @poles.setter
    def poles(self, poles) -> None: ...
    @property
    def gain(self): ...
    @gain.setter
    def gain(self, gain) -> None: ...
    def to_tf(self): ...
    def to_zpk(self): ...
    def to_ss(self): ...

class ZerosPolesGainContinuous(ZerosPolesGain, lti):
    def to_discrete(self, dt, method: str = 'zoh', alpha: Incomplete | None = None): ...

class ZerosPolesGainDiscrete(ZerosPolesGain, dlti): ...

class StateSpace(LinearTimeInvariant):
    __array_priority__: float
    __array_ufunc__: Incomplete
    def __new__(cls, *system, **kwargs): ...
    def __init__(self, *system, **kwargs) -> None: ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __neg__(self): ...
    def __add__(self, other): ...
    def __sub__(self, other): ...
    def __radd__(self, other): ...
    def __rsub__(self, other): ...
    def __truediv__(self, other): ...
    @property
    def A(self): ...
    @A.setter
    def A(self, A) -> None: ...
    @property
    def B(self): ...
    inputs: Incomplete
    @B.setter
    def B(self, B) -> None: ...
    @property
    def C(self): ...
    outputs: Incomplete
    @C.setter
    def C(self, C) -> None: ...
    @property
    def D(self): ...
    @D.setter
    def D(self, D) -> None: ...
    def to_tf(self, **kwargs): ...
    def to_zpk(self, **kwargs): ...
    def to_ss(self): ...

class StateSpaceContinuous(StateSpace, lti):
    def to_discrete(self, dt, method: str = 'zoh', alpha: Incomplete | None = None): ...

class StateSpaceDiscrete(StateSpace, dlti): ...

def lsim(system, U, T, X0: Incomplete | None = None, interp: bool = True): ...
def impulse(system, X0: Incomplete | None = None, T: Incomplete | None = None, N: Incomplete | None = None): ...
def step(system, X0: Incomplete | None = None, T: Incomplete | None = None, N: Incomplete | None = None): ...
def bode(system, w: Incomplete | None = None, n: int = 100): ...
def freqresp(system, w: Incomplete | None = None, n: int = 10000): ...

class Bunch:
    def __init__(self, **kwds) -> None: ...

def place_poles(A, B, poles, method: str = 'YT', rtol: float = 0.001, maxiter: int = 30): ...
def dlsim(system, u, t: Incomplete | None = None, x0: Incomplete | None = None): ...
def dimpulse(system, x0: Incomplete | None = None, t: Incomplete | None = None, n: Incomplete | None = None): ...
def dstep(system, x0: Incomplete | None = None, t: Incomplete | None = None, n: Incomplete | None = None): ...
def dfreqresp(system, w: Incomplete | None = None, n: int = 10000, whole: bool = False): ...
def dbode(system, w: Incomplete | None = None, n: int = 100): ...
